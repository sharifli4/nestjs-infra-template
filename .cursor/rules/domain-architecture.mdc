# Domain-Centric Architecture Rules for AI Agents

This document provides strict rules for AI agents when organizing code in this NestJS project.

## ğŸ¯ Core Principle

**NO `common/` or `utils/` folders. Everything is domain-centric.**

---

## ğŸ“ Project Structure Rules

### Rule 1: Use Domain-First Organization

```
src/
â”œâ”€â”€ core/                    # âœ… Core infrastructure only
â”‚   â”œâ”€â”€ exceptions/          # Exception handling system
â”‚   â”œâ”€â”€ factories/           # Module factories
â”‚   â””â”€â”€ guards/              # Auth guards, etc.
â”‚
â”œâ”€â”€ config/                  # âœ… Infrastructure config only
â”‚   â”œâ”€â”€ database.config.ts
â”‚   â”œâ”€â”€ redis.config.ts
â”‚   â””â”€â”€ logger.config.ts
â”‚
â”œâ”€â”€ database/                # âœ… Base entities only
â”‚   â”œâ”€â”€ base.entity.ts
â”‚   â””â”€â”€ soft-deletable.entity.ts
â”‚
â”œâ”€â”€ logger/                  # âœ… Logging infrastructure
â”œâ”€â”€ redis/                   # âœ… Caching infrastructure
â”œâ”€â”€ vault/                   # âœ… Secret management
â”‚
â””â”€â”€ features/                # âœ… All business domains
    â”œâ”€â”€ users/
    â”‚   â”œâ”€â”€ config/
    â”‚   â”‚   â””â”€â”€ users.config.ts
    â”‚   â”œâ”€â”€ entities/
    â”‚   â”œâ”€â”€ dto/
    â”‚   â”œâ”€â”€ exceptions/
    â”‚   â”œâ”€â”€ services/
    â”‚   â”œâ”€â”€ controllers/
    â”‚   â”œâ”€â”€ users.module.ts
    â”‚   â””â”€â”€ tests/
    â”‚
    â””â”€â”€ [other-domains]/
```

### Rule 2: Forbidden Folders

**NEVER create these folders:**

```
âŒ src/common/
âŒ src/utils/
âŒ src/helpers/
âŒ src/shared/
âŒ src/lib/
âŒ src/utilities/
```

---

## ğŸ—ï¸ Where to Put What

### Infrastructure Code â†’ `src/core/`

Place in `src/core/` if it's:
- Exception handling system
- Guards (auth, roles, etc.)
- Interceptors (global)
- Filters (global)
- Decorators (cross-domain)
- Factories (module loading)
- Pipes (global validation)

**Examples:**
```
src/core/
â”œâ”€â”€ exceptions/              # Exception system
â”œâ”€â”€ factories/               # Module factories
â”œâ”€â”€ guards/
â”‚   â”œâ”€â”€ jwt-auth.guard.ts
â”‚   â””â”€â”€ roles.guard.ts
â”œâ”€â”€ decorators/
â”‚   â”œâ”€â”€ current-user.decorator.ts
â”‚   â””â”€â”€ roles.decorator.ts
â””â”€â”€ interceptors/
    â””â”€â”€ transform-response.interceptor.ts
```

### Domain-Specific Code â†’ `src/features/{domain}/`

Place in domain folder if it's:
- Business logic
- Domain entities
- Domain DTOs
- Domain exceptions
- Domain services
- Domain controllers
- Domain configuration
- Domain utilities (domain-specific helpers)

**Example: Users Domain**
```
src/features/users/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ users.config.ts           # User domain config
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ user.entity.ts
â”‚   â””â”€â”€ user-profile.entity.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-user.dto.ts
â”‚   â””â”€â”€ update-user.dto.ts
â”œâ”€â”€ exceptions/
â”‚   â”œâ”€â”€ user-not-found.exception.ts
â”‚   â””â”€â”€ email-already-exists.exception.ts
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ users.service.ts
â”‚   â””â”€â”€ user-profile.service.ts
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ users.controller.ts
â”œâ”€â”€ utils/                         # âœ… Domain-specific utils
â”‚   â”œâ”€â”€ hash-user-id.util.ts      # Only used in users domain
â”‚   â””â”€â”€ validate-username.util.ts
â”œâ”€â”€ users.module.ts
â””â”€â”€ tests/
    â”œâ”€â”€ users.service.spec.ts
    â””â”€â”€ users.controller.spec.ts
```

### Infrastructure Services â†’ Dedicated folders

Place in root-level folders:
- `src/logger/` - Logging infrastructure
- `src/redis/` - Caching infrastructure
- `src/database/` - Database base entities
- `src/config/` - Infrastructure configs

---

## ğŸ¨ Configuration Rules

### Rule 3: Domain-Isolated Configuration

Each domain has its own config:

```typescript
// âœ… src/features/users/config/users.config.ts
export default registerAs('users', () => ({
  hashIdSalt: process.env.USERS_HASHID_SALT,
  maxLoginAttempts: parseInt(process.env.USERS_MAX_LOGIN_ATTEMPTS || '5'),
}));

// âœ… src/features/notifications/config/notifications.config.ts
export default registerAs('notifications', () => ({
  smtpHost: process.env.NOTIFICATIONS_SMTP_HOST,
  smtpPort: parseInt(process.env.NOTIFICATIONS_SMTP_PORT || '587'),
}));
```

### Rule 4: Configuration Access

```typescript
// âœ… CORRECT: Access only your domain's config
@Injectable()
export class UsersService {
  private readonly config: UsersConfig;

  constructor(private configService: ConfigService) {
    this.config = this.configService.get<UsersConfig>('users')!;
  }
}

// âŒ WRONG: Don't access other domain configs
@Injectable()
export class UsersService {
  constructor(private configService: ConfigService) {
    // âŒ Users service shouldn't access notifications config
    const smtp = this.configService.get<NotificationsConfig>('notifications');
  }
}
```

---

## ğŸ“¦ Module Organization

### Rule 5: Feature Module Structure

Every feature domain MUST have this structure:

```
feature-name/
â”œâ”€â”€ config/                    # Domain configuration
â”œâ”€â”€ entities/                  # Database entities
â”œâ”€â”€ dto/                       # Data Transfer Objects
â”œâ”€â”€ exceptions/                # Domain exceptions
â”œâ”€â”€ services/                  # Business logic
â”œâ”€â”€ controllers/               # HTTP endpoints
â”œâ”€â”€ repositories/              # Data access (if needed)
â”œâ”€â”€ utils/                     # Domain-specific utilities
â”œâ”€â”€ tests/                     # Tests
â”œâ”€â”€ feature-name.module.ts     # Module definition
â””â”€â”€ index.ts                   # Barrel exports (optional)
```

### Rule 6: Module Registration

```typescript
// src/features/users/users.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import usersConfig from './config/users.config';

@Module({
  imports: [
    ConfigModule.forFeature(usersConfig), // Register domain config
    // Other imports
  ],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

---

## ğŸ”§ Utility Functions

### Rule 7: Domain-Specific Utils

If a utility is used by ONE domain, put it IN that domain:

```typescript
// âœ… CORRECT: Domain-specific utility
// src/features/users/utils/hash-user-id.util.ts
export function hashUserId(id: number): string {
  // Only used in users domain
  return hashids.encode(id);
}
```

### Rule 8: Cross-Domain Utils â†’ Core

If a utility is used by MULTIPLE domains, put it in `src/core/`:

```typescript
// âœ… CORRECT: Used by multiple domains
// src/core/utils/date.util.ts
export function formatDate(date: Date): string {
  // Used by users, orders, payments, etc.
  return date.toISOString();
}
```

**But ask yourself:** Should this be a service instead?

```typescript
// âœ… BETTER: Make it a service
// src/core/services/date-formatter.service.ts
@Injectable()
export class DateFormatterService {
  format(date: Date): string {
    return date.toISOString();
  }
}
```

---

## ğŸ¯ Dependency Rules

### Rule 9: Dependency Direction

```
Features can depend on:
  âœ… Core infrastructure
  âœ… Shared infrastructure (logger, redis, database)
  âŒ Other feature domains (NO cross-domain dependencies)

Core can depend on:
  âœ… Nothing (it's the foundation)

Infrastructure can depend on:
  âœ… Core
  âŒ Features
```

**Example:**

```typescript
// âœ… CORRECT: Users domain uses core infrastructure
import { CustomLoggerService } from '@/logger/logger.service';
import { RedisService } from '@/redis/redis.service';
import { NotFoundException } from '@/core/exceptions';

// âŒ WRONG: Users domain depends on Orders domain
import { OrdersService } from '@/features/orders/services/orders.service';
```

---

## ğŸ”„ Shared Logic Between Domains

### Rule 10: How to Share Logic

If multiple domains need the same logic:

**Option 1: Create a Core Service**
```typescript
// src/core/services/email-validator.service.ts
@Injectable()
export class EmailValidatorService {
  validate(email: string): boolean {
    // Validation logic
  }
}
```

**Option 2: Create a Separate Shared Domain**
```typescript
// If the logic is complex enough
src/features/
â”œâ”€â”€ shared/                # Shared business logic
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ email-validator.service.ts
â”‚   â””â”€â”€ shared.module.ts
â”œâ”€â”€ users/
â””â”€â”€ notifications/
```

**Option 3: Use Events**
```typescript
// Decouple domains with events
@Injectable()
export class UsersService {
  async createUser(dto: CreateUserDto) {
    const user = await this.save(dto);
    
    // Emit event instead of calling NotificationsService directly
    this.eventEmitter.emit('user.created', { userId: user.id });
  }
}

// In notifications domain
@OnEvent('user.created')
handleUserCreated(payload: { userId: string }) {
  this.sendWelcomeEmail(payload.userId);
}
```

---

## ğŸ“ Entity Organization

### Rule 11: Base Entities in database/, Domain Entities in features/

```typescript
// âœ… src/database/base.entity.ts - Base for all entities
export abstract class BaseEntity {
  @Property()
  createdAt: Date = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt: Date = new Date();
}

// âœ… src/features/users/entities/user.entity.ts - Domain entity
@Entity()
export class User extends BaseEntity {
  @PrimaryKey()
  id!: number;

  @Property()
  email!: string;
}
```

---

## ğŸ§ª Testing Organization

### Rule 12: Tests Go With Their Code

```
src/features/users/
â”œâ”€â”€ services/
â”‚   â””â”€â”€ users.service.ts
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ users.controller.ts
â””â”€â”€ tests/                      # Tests for this domain
    â”œâ”€â”€ users.service.spec.ts
    â”œâ”€â”€ users.controller.spec.ts
    â””â”€â”€ integration/
        â””â”€â”€ users.integration.spec.ts
```

**NOT:**
```
âŒ test/unit/users/
âŒ test/integration/users/
```

---

## ğŸ“‹ Checklist for New Features

When creating a new feature domain:

- [ ] Create folder in `src/features/{domain-name}/`
- [ ] Add domain configuration in `config/`
- [ ] Create entities in `entities/`
- [ ] Create DTOs in `dto/`
- [ ] Create domain exceptions in `exceptions/`
- [ ] Create services in `services/`
- [ ] Create controllers in `controllers/`
- [ ] Create module file `{domain-name}.module.ts`
- [ ] Register domain config with `ConfigModule.forFeature()`
- [ ] Add tests in `tests/`
- [ ] Export module in `src/app.module.ts`
- [ ] Document domain in README (optional)

---

## ğŸš« Common Mistakes

### âŒ DON'T: Create shared folders

```typescript
// âŒ WRONG
src/
â”œâ”€â”€ common/
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ string.util.ts
â””â”€â”€ shared/
    â””â”€â”€ helpers/
        â””â”€â”€ date.helper.ts
```

### âŒ DON'T: Cross-domain dependencies

```typescript
// âŒ WRONG: Orders depending on Users
// src/features/orders/services/orders.service.ts
import { UsersService } from '@/features/users/services/users.service';

@Injectable()
export class OrdersService {
  constructor(private usersService: UsersService) {} // âŒ NO!
}
```

### âŒ DON'T: Put everything in core

```typescript
// âŒ WRONG: Business logic in core
src/core/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ calculate-user-age.service.ts    // âŒ Should be in users domain
â”‚   â””â”€â”€ format-order-total.service.ts    // âŒ Should be in orders domain
```

---

## âœ… Good Examples

### Example 1: Users Domain

```
src/features/users/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ users.config.ts
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ user.entity.ts
â”‚   â””â”€â”€ user-session.entity.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-user.dto.ts
â”‚   â”œâ”€â”€ update-user.dto.ts
â”‚   â””â”€â”€ login.dto.ts
â”œâ”€â”€ exceptions/
â”‚   â”œâ”€â”€ user-not-found.exception.ts
â”‚   â”œâ”€â”€ email-already-exists.exception.ts
â”‚   â””â”€â”€ invalid-credentials.exception.ts
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ users.service.ts
â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â””â”€â”€ user-session.service.ts
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ users.controller.ts
â”‚   â””â”€â”€ auth.controller.ts
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ hash-user-id.util.ts
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ users.service.spec.ts
â”‚   â””â”€â”€ auth.service.spec.ts
â”œâ”€â”€ users.module.ts
â””â”€â”€ index.ts
```

### Example 2: Core Infrastructure

```
src/core/
â”œâ”€â”€ exceptions/              # Exception system
â”‚   â”œâ”€â”€ http/
â”‚   â”œâ”€â”€ database/
â”‚   â””â”€â”€ decorators/
â”œâ”€â”€ factories/               # Module factories
â”‚   â”œâ”€â”€ database-module.factory.ts
â”‚   â””â”€â”€ redis-module.factory.ts
â”œâ”€â”€ guards/                  # Auth guards
â”‚   â”œâ”€â”€ jwt-auth.guard.ts
â”‚   â””â”€â”€ roles.guard.ts
â”œâ”€â”€ decorators/              # Custom decorators
â”‚   â”œâ”€â”€ current-user.decorator.ts
â”‚   â””â”€â”€ roles.decorator.ts
â””â”€â”€ interceptors/            # Global interceptors
    â””â”€â”€ transform-response.interceptor.ts
```

---

## ğŸ“ Summary for AI Agents

**Golden Rules:**

1. **NO `common/` or `utils/` folders**
2. **Domain-first organization** - Put code with its domain
3. **Configuration isolation** - Each domain has its own config
4. **No cross-domain dependencies** - Use events or core services
5. **Infrastructure in core** - Only truly cross-cutting concerns
6. **Domain-specific utils stay in domain** - Don't extract prematurely
7. **Tests with code** - Not in separate test/ folder
8. **Base entities in database/** - Domain entities in features/
9. **Think twice before core** - Most things belong in a domain
10. **Use dependency direction rules** - Features â†’ Core, never Features â†’ Features

**Remember:** When in doubt, keep it in the domain. Extract to core only when you're SURE it's used everywhere!
